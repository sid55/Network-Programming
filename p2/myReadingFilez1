      fileSize = atoi(subBuff);
            avgBytes = fileSize/minimum;
            remainderBytes = fileSize%minimum;
            bzero(recvline,MAXLINE);
            break; 
        }
    }

    close(sockfd);
    rewind(fp);
}

/*
 * This method actually tries to connect the client with the server
 * by using the connect system call.
 */ 
void connectSocket(int sockfd){      
    if (connect(sockfd, (struct sockaddr *) &servaddr2, sizeof(servaddr2)) < 0){
        perror("connect error\n");
        exit(1);
    }
}

/*
 * Sets avg, total, and remainder in thread_ptr
 */
void setAvgEtc(){
    int count = 1;
    int minTemp = minimum - 1;
    //can check avgbytes etc info here
    //printf("avgBytes is: %d",avgBytes);
    //printf("fileSize is: %d",fileSize);

    thread_pnt[0].fileSize = fileSize;
    thread_pnt[0].remainderBytes = remainderBytes;
    thread_pnt[0].avgBytes = avgBytes;
 
    while(count <= minTemp){
        thread_pnt[count].fileSize = fileSize;
        thread_pnt[count].remainderBytes = 0;
        thread_pnt[count].avgBytes = avgBytes;
        count++;
    }
    printf("THE AVG BYTES 111 IS: %d\n",thread_pnt[0].avgBytes);
    printf("THE AVG BYTES 222 IS: %d\n",thread_pnt[1].avgBytes);
    printf("THE AVG BYTES 333 IS: %d\n",thread_pnt[2].avgBytes);
    printf("THE MINIMUM IS: %d\n",minimum);
}

/*
 * The main logic of this program is in this method. The client 
 * communicates with the server using the send and recv system 
 * calls. It has two buffers, one for sending messages and one
 * for recieving messages. This entire method is put under a while
 * loop to allow the client to continuously send messages to the
 * server and there is a seperate while loop inside this client
 * for receiving messages in case the message being sent by the server
 * will require multiple packets. If there are any problems using
 * those two system calls, errors are thrown respectively.
 *
 * This method will call createServerHelper and connectSocket within
 * a loop as well.
 */
void readWriteSocket(Thread threadInfo){
    int sendfd;
    int recfd; //the file descriptor for recieving messages
    int setBreak = 0; //variable set/unset when wanting to break while loops
    struct sockaddr_in servaddr; //the server address


    int sockfd = createSocket();

    //Create the server with its info below
    int port;
    char ipAddr[1024]; //max length of ipaddress - used when opneing file
    char portNumbr[1024]; //max length of portNumbr - used when opening file

    int countdown = threadInfo.thread_id;
    while (countdown > 0){
        fscanf(threadInfo.fp,"%s %s",ipAddr,portNumbr);
        countdown--;
    }

    if(fscanf(threadInfo.fp,"%s %s",ipAddr,portNumbr) > 0){
        printf("%s %s \n",ipAddr,portNumbr);
        if (strncmp(ipAddr,"localhost",9) == 0){
            sscanf(portNumbr,"%d",&port);  //port number specified
            bzero(&servaddr, sizeof(servaddr));
            servaddr.sin_family = AF_INET;
            servaddr.sin_port = htons(port); //port number being set
    
            //ip address specified below by the user  
            if (inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr) <= 0){
                perror("inet_pton error");
                exit(1);
            }
        }else{   
            sscanf(portNumbr,"%d",&port);  //port number specified
            bzero(&servaddr, sizeof(servaddr));
            servaddr.sin_family = AF_INET;
            servaddr.sin_port = htons(port); //port number being set
    
            //ip address specified below by the user  
            if (inet_pton(AF_INET, ipAddr, &servaddr.sin_addr) <= 0){
                perror("inet_pton error");
                exit(1);
            }
        }        
    }

    //connect the the server's socket here
    if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0){
        perror("connect error\n");
        exit(1);
    }

      //infinite while loop that exits either during an error
      //or when the client sends an "exit" message
      while(1){
            //allows sending a string fiexitfile should be server-info.txt\n");
        exit(EXIT_FAILURE);
    }
    threadInfo.fp = fopen(filename,"r");
    if (threadInfo.fp == NULL){
        perror("The file you are trying to open does not exist\n");
        exit(1);
    }
}


/*
 * Finds the next server in list of servers and sets its
 * variables on the client side
 */
void createServerHelper(int sockfd){
    char ipAddr[1024]; //max length of ipaddress - used when opneing file
    char portNumbr[1024]; //max length of portNumbr - used when opening file
    if(fscanf(fp,"%s %s",ipAddr,portNumbr) > 0){
        printf("%s %s \n",ipAddr,portNumbr);
        if (strncmp(ipAddr,"localhost",9) == 0)
            createServer("127.0.0.1",portNumbr);
        else   
            createServer(ipAddr,portNumbr);
            //createServer("127.0.0.1",portNumbr);
    }
}

/*
 * Gets the minimum between the number of the connections the user enters
 * and the number of servers available for usage
 */
void getMin(const char *numConnections, const char *filename, const char* fileOnServer){
    int tempNumConnections = -1;
    int tempNumLines = 0;
    int ch = 0;

    /*
     * Find number of lines and set numConnections to int
     */
    sscanf(numConnections,"%d",&tempNumConnections); //converts connection number to int
    while(!feof(fp)){
        ch = fgetc(fp);
        if (ch == '\n'){
            tempNumLines++;
        }
    }
    rewind(fp);

    printf("tempNumconnections is: %d tempNumlines is: %d",tempNumConnections,tempNumLines);

    int minimumTemp;
    //Set the minimum to one of those values
    if(tempNumLines <= tempNumConnections){
        minimumTemp = tempNumLines;
        minimum = tempNumLines;
    }else{
        minimumTemp = tempNumConnections;
        minimum = tempNumConnections;
    }

    //zero connections = throw error
    if (minimumTemp == 0){
        perror("Not enough servers to connect to\n");
        exit(1);
    }

    //set minimum in thread struct
    thread_pnt = (Thread*)malloc(minimumTemp*sizeof(Thread));
    int minTemp = minimumTemp -1;
    while(minTemp > -1){
        thread_pnt[minTemp].minimum = minimumTemp;
        minTemp--;
    }

    //set tempVal used for calculation in thread struct   
    thread_pnt[0].tempVal = 0;
    minTemp = minimumTemp - 1;
    while(minTemp > 0){
        thread_pnt[minTemp].tempVal = 1;
        minTemp--;
    }

    //set thread_id in this method
    int count = 0;
    minTemp = minimumTemp - 1;
    while(count <= minTemp){
        thread_pnt[count].thread_id = count;
        count++;
    }

    //set setFile in this method
    minTemp = minimumTemp - 1;
    while(minTemp > -1){
        thread_pnt[minTemp].setFile = 0;
        minTemp--;
    }

    //set fp in this piece of code
    count = 0;
    minTemp = minimumTemp - 1;
    while(count <= minTemp){
        if (strncmp(filename,"server-info.txt",15) != 0){
            perror("The file should be server-info.txt\n");
            exit(EXIT_FAILURE);
        }
        thread_pnt[count].fp = fopen(filename,"r");
        if (thread_pnt[count].fp == NULL){
            perror("The file you are trying to open does not exist\n");
            exit(1);
        }
        count++;
    }

    //set reader file pointer in this set of code
    count = 0;
    minTemp = minimumTemp - 1;
    char fileName2[200];
    while (count <= minTemp){
        sprintf(fileName2,"myReadingFilez");
        sprintf(fileName2 + strlen(fileName2), "%d", (long) (count));
        sprintf(thread_pnt[count].fileOnServer,fileName2); 
        thread_pnt[count].reader = fopen(fileName2,"a");
        bzero(fileName2,200);
        count++;
    }

    //set counter in this set of code
    count = 0;
    minTemp = minimumTemp - 1;
    while(count <= minTemp){
        thread_pnt[count].counter = count;
        count++;
    }

    count = 0;
    minTemp = minimumTemp -1;
    while(count <= minTemp){
        sprintf(thread_pnt[count].myFileName,fileOnServer);
        count++;
    }
    //thread_pnt[1].thread_id = 5;

}

void getFileSize(const char* fileName){

    int sockfd = createSocke