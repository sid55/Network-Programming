tesDivisible){
                        printf("came into here early!!\n");
                        setForExit = 1;
                    }
                }
                if ((writefd = write(connfd, sendBuff, strlen(sendBuff))) > 0) {
                    //sendBuff[strlen(sendBuff)] = '\0';
                    printf("PRINT: %s\n", sendBuff);
                    printf("\n\n\nstuck here?\n\n\n");
                    bzero(sendBuff,MAXLINE2);
                }

                printf("\n\n\n\n\n\nITERATION\n\n\n\n\n\n");

                if(writefd < 0){
                    perror("was not able to write data correctly\n");
                    exit(1);
                }else if(writefd == 0){
                   bzero(sendBuff,MAXLINE2);
                   sprintf(sendBuff,"exit");
                   writefd = write(connfd,sendBuff,strlen(sendBuff));
                   if (writefd < 0){
                        perror("server not able to write");
                        exit(1);
                   }
                   bzero(sendBuff,MAXLINE2);
                }
     
                bzero(sendBuff,MAXLINE2);
                temp++;
            }
            printf("333333333333333333333333333\n");
            fclose(fileRead); //fclose here?

              bzero(sendBuff,MAXLINE2);
              bzero(recvBuff,MAXLINE2);
        }
        else{
              printf("Came into section not supposed to yet\n");
        }
        printf("sanity check\n");
        bzero(recvBuff,MAXLINE2); //zeroes/resets the buffer
        if(setForExit == 1){
            printf("gets into break early\n");
            break;
        }
    }
    printf("Left while loop\n");
    //this is for when the client is done sending
    //its messages to the server. The client disconnects.     
    if(read_size == 0 || setForExit == 1)
    {
        printf("the read_size is 0\n");
        printf("before close connfd is: %d\n",connfd);
        close(connfd); //closes the file descriptor returned by accept
        printf("after close connfd is: %d\n",connfd);
    }
    else if(read_size < 0)
    {
        perror("recv failed on server\n");
    }
}

/*
 * This method allows the connection to the server to happen
 * for the client with the accept system call. It then calls
 * the main meat of this program, readWriteServer which is 
 * a method that is briefly explained above. There is a while
 * loop to ensure that when the client exits, a new connection
 * can be established with the server.
 */
void acceptReadWriteServer(int listenfd){
  while(1){
    int connfd = acceptServer(listenfd);
    readWriteServer(connfd, listenfd); //contains code for receiving and sending data
  }
}

/*
 * This is the class's main which gets executed when this 
 * program is run.
 */
int
main(int argc, char **argv)
{
  numArgs(argc);
  int listenfd = createListenSocket(); //the file desriptor for the socket on server
  createServer(argv[1]);
  bindServer(listenfd);
  listenServer(listenfd);
  acceptReadWriteServer(listenfd);
  exit(1);
  return 0;
